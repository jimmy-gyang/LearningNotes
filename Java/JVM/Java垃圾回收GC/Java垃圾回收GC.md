垃圾收集(Garbage Collection, GC)，需要完成3件事情:
1. 哪些内存需要回收?
2. 什么时候回收?
3. 如何回收?

之前介绍了Java内存运行时区域的各个部分，错过的同学可以看这里。

其中程序计数器、虚拟机栈、本地方法栈3个区域随线程而生，随线程而灭; 栈中的栈帧随着方法的进入和退出而有条不紊地执行着出栈和入栈操作。每一个栈帧中分配多少内存基本上是在类结构确定下来时就已知的，因此这几个区域的内存分配和回收都具备确定性，在这几个区域内就不需要过多考虑回收的问题，因为方法结束或者线程结束时，内存自然就跟随着回收了。而Java堆和方法区则不一样，一个接口中的多个实现类需要的内存可能不一样，一个方法中的多个分支需要的内存也
可能不一样，我们只有在程序处于运行期间时才能知道会创建哪些对象，这部分内存的分配和回收都是动态的，垃圾收集器所关注的是这部分内存。

### 对象已死吗？
在堆里面存放着Java世界中几乎所有的对象实例，垃圾收集器在对堆进行回收前，第一件事情就是要确定这些对象之中哪些还“存活”着，哪些已经“死去”(即不可能再被任何途径使用的对象)。

#### 引用计数法
很多教科书判断对象是否存活的算法是这样的: 给对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加1; 当引用失效时，计数器值就减1; 任何时刻计数器为0的对象就是不可能再被使用的。客观地说，引用计数算法(Reference Counting)的实现简单，判定效率也很高，在大部分情况下它都是一个不错的算法，但是，至少主流的 Java虚拟机里面没有选用引用计数算法来管理内存，其中最主要的原因是它很难解决对象之间相互循环引用的问题。

#### 可达性分析算法
虚拟机主流实现中，都是称通过可达性分析(Reachability Analysis)来判定对象是否存活的。这个算法的基本思路就是通过一系列的称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链(Reference Chain)，当一个对象到GC Roots没有任何引用链相连(用图论的话来说，就是从GC Roots到这个对象不可达)时，则证明此对象是不可用的。

在Java语言中，可作为GC Roots的对象包括下面几种:
* 虚拟机栈(枝帧中的本地变量表)中引用的对象。
* 方法区中类静态属性引用的对象。
* 方法区中常量引用的对象 。
* 本地方法战中 JNI (即一般说的 Native 方法)引用的对象。

### 引用对象
无论是通过引用计数算法判断对象的引用数量，还是通过可达性分析算法判断对象的引用链是否可达，判定对象是否存活都与“引用”有关。在JDK 1.2以前， Java中的引用的定义很传统: 如果reference类型的数据中存储的数值代表的是另外一块内存的起始地址，就称这块内存代表着一个引用。这种定义很纯粹，但是太过狭隘，一个对象在这种定义下只有被引用或者没有被引用两种状态，对于如何描述一些“食之无味，弃之可惜”的对象就显得无能为力。我们希望能描述这样一类对象:当内存空间还足够时，则能保留在内存之中; 如果内存空间在进行垃圾收集后还是非常紧张，则可以抛弃这些对象。很多系统的缓存功能都符合这样的应用场景。

在JDK1.2之后，Java对引用的概念进行了扩充，将引用分为强引用(Strong Reference)、软引用(SoftReference)、弱引用(WeakReference)、虚引用 (PhantomReference)4种，这4种引用强度依次逐渐减弱。

* 强引用就是指在程序代码之中普遍存在的 ，类似“Object obj = new Object()”这类的引用，只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象。
* 软引用是用来描述一些还有用但并非必需的对象。对于软引用关联着的对象，在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行第二次回收。如果这次回收还没有足够的内存，才会抛出内存溢出异常。在JDK 1.2之后，提供了SoftReference类来实现软引用。
* 弱引用也是用来描述非必需对象的，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生之前。当垃圾收集器工作时，无论当 前内存是否足够，都会回收掉只被弱引用关联的对象。在JDK 1.2之后，提供了WeakReference类来实现弱引用。
* 虚引用也称为幽灵引用或者幻影引用，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。在JDK 1.2之后，提供了 PhantomReference类来实现虚引用。

### 小结
本文介绍了Java垃圾收集器回收的内存部分，以及如何判断对象是否需要回收。接下来将会详细介绍如何回收部分，也就是垃圾回收算法。

