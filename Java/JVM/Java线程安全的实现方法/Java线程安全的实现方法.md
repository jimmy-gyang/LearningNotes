Java实现线程安全有两个方面，一是虚拟机提供的同步和锁机制，二是程序编写者们代码编写的方式。接下来将围绕这两个方面来介绍Java线程安全的实现方法。

### 互斥同步
互斥同步(Mutual Exclusion & Synchronization)是常见的一种并发正确性保障手段。同步是指在多个线程并发访问共享数据时，保证共享数据在同一个时刻只被一个(或者是一些，使用信号量的时候)线程使用。而互斥是实现同步的一种手段，临界区(Critical Section)、互斥量 (Mutex)和信号量 CSemaphore)都是主要的互斥实现方式。

在Java中，最基本的互斥同步手段就是synchronized关键字，synchronized关键字经过编译之后，会在同步块的前后分别形成monitorenter和monitorexit这两个字节码指令，这两个字节码都需要一个reference类型的参数来指明要锁定和解锁的对象。如果Java程序中的synchronized明确指定了对象参数，那就是这个对象的reference ;如果没有明确指定，那就根据 synchronized修饰的是实例方法还是类方法，去取对应的对象实例或 Class对象来作为锁对象。

根据虚拟机规范的要求，在执行monitorenter指令时，首先要尝试获取对象的锁。如果这个对象没被锁定，或者当前线程已经拥有了那个对象的锁，把锁的计数器加1，相应的，在执行monitorexit指令时会将锁计数器减1，当计数器为0时，锁就被释放。如果获取对象锁失败，那当前线程就要阻塞等待，直到对象锁被另外一个线程释放为止。

在虚拟机规范对monitorenter和monitorexit的行为描述中，有两点是需要特别注意的。 首先，synchronized同步块对同一条线程来说是可重入的，不会出现自己把自己锁死的问题。其次，同步块在已进入的线程执行完之前，会阻塞后面其他线程的进入。

除了synchronized之外，我们还可以使用java.util.concurrent包中的重 入锁(ReentrantLock)来实现同步，在基本用法上，ReentrantLock与synchronized很相似，他们都具备一样的线程重入特性，只是代码写法上有点区别，一个表现为API层面的互斥锁(lock()和 unlock()方法配合 try/fina11y语句块来完成)，另一个表现为原生语法层面的互斥锁。不过，相比synchronized, ReentrantLock 增加了一些高级功能，主要有以下3项: 等待可中断、可实现公平锁，以及锁可以绑定多个条件。

* 等待可中断是指当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，改为处理其他事情，可中断特性对处理执行时间非常长的同步块很有帮助。
* 公平锁是指多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁: 而非公平锁则不保证这一点，在锁被释放时，任何一个等待锁的线程都有机会获得锁。 synchronized中的锁是非公平的，ReentrantLock默认情况下也是非公平的，但可以通过带布尔值的构造函数要求使用公平锁。
* 锁绑定多个条件是指一个ReentrantLock对象可以同时绑定多个Condition对象，而在synchronized中，锁对象的 wait()和 notify()或 notifyAll()方法可以实现一个隐含的条件，如果要和多于二个的条件关联的时候，就不得不额外地添加一个锁，而ReentrantLock则无须这样做，只需要多次调用newCondition()方法即可。

### 非阻塞同步

互斥同步最主要的问题就是进行线程阻塞和唤醒所带来的性能问题，因此这种同步也称为阻塞同步(Blocking Synchronization)。 从处理问题的方式上说，互斥同步属于一种悲观的并发策略，总是认为只要不去做正确的同步措施(例如加锁)，那就肯定会出现问题，无论共享数据是否真的会出现竞争，它都要进行加锁(这里讨论的是概念模型，实际上虚拟机会优化掉很大一部分不必要的加锁)、用户态核心态转换、维护锁计数器和检查是否有被阻 塞的线程需要唤醒等操作。随着硬件指令集的发展，我们有了另外一个选择: 基于冲突检测的乐观并发策略 ，通俗地说， 就是先进行操作 ，如果没有其他线程争用共享数据，那操作就 成功了;如果共享数据有争用，产生了冲突，那就再采取其他的补偿措施(最常见的补偿措 施就是不断地重试，直到成功为止)，这种乐观的并发策略的许多实现都不需要把线程挂起， 因此这种同步操作称为非阻塞同步(Non-Blocking Synchronization)。

CAS就是其中一种操作。在JDK1.5之后，Java程序中才可以使用CAS操作，该操作由sun.misc.Unsafe类里面的compareAndSwaplnt()和 compareAndSwapLong()等几个方法包装提供，虚拟机在内部对这些方法做了特殊处理，即时编译出来的结果就是一条平台相关的处理器CAS指令，没有 方法调用的过程，或者可以认为是无条件内联进去了。

尽管CAS看起来很美，但显然这种操作无法涵盖互斥同步的所有使用场景，并且 CAS从语义上来说并不是完美的，存在这样的一个逻辑漏洞: 如果一个变量V初次读取的时候是A值，并且在准备赋值的时候检查到它仍然为A值，那我们就能说它的值没有被其他线程改变过了吗? 如果在这段期间它的值曾经被改成了B，后来又被改因为A，那CAS操作就会误认为它从来没有被改变过。这个漏洞称为CAS操作的“ ABA”问题。J.U.C包为了解决这个问题，提供了一个带有标记的原子引用类AtomicStampedReference，它可以通过控制变量值的版本来保证CAS的正确性 。 不过目前来说这个类比较“鸡肋”，大部分情况下ABA问题不会影响程序井发的正确性，如果需要解决ABA问题，改用传统的互斥同步可能会比原子类更高效。

### 无同步方案
要保证线程安全，并不是一定就要进行同步，两者没有因果关系。 同步只是保证共享数据争用时的正确性的手段，如果一个方法本来就不涉及共享数据，那它自然就无须任何同步措施去保证正确性，因此会有一些代码天生就是线程安全的，下面简单地介绍其中的两类。

**可重入代码 (Reentrant Code):** 这种代码也叫做纯代码(Pure Code)，可以在代码执行的任何时刻中断它，转而去执行另外一段代码(包括递归调用它本身)，而在控制权返回后，原来的程序不会出现任何错误。相对线程安全来说，可重人性是更基本的特性，它可以保证线程安全，即所有的可重人的代码都是线程安全的，但是并非所有的线程安全的代码都是可重入的。

**线程本地存储(Thread Local Storage):** 如果一段代码中所需要的数据必须与其他代码共享，那就看看这些共享数据的代码是否能保证在同一个线程中执行。如果能保证，我们就可以把共享数据的可见范围限制在同一个线程之内，这样，无须同步也能保证线程之间不出现数据争用的问题。

Java语言中，如果一个变量要被多线程访问，可以使用volatile关键宇声明它为“易变”的。如果一个变量要被某个线程独享，可以通过java.lang。ThreadLocal类来实现线程本地存储的功能。每一个线程的Thread对象中都有一个ThreadLocalMap对象，这个对象存储了一组以ThreadLocal. threadLocalHashCode为键，以本地线程变量为值的K-V值对，ThreadLocal对象就是当前线程的ThreadLocalMap 的访问入口，每一个ThreadLocal对象都包含了一个独一无二的threadLoca旧ashCode值，使用这个值就可以在线程 K-V值对中找回对应的本地线程变量。

## 小结
本次介绍了三种Java实现安全的方法，不过主要是偏向理论上的方案，具体的实现还是需要在平时编码中多多实践，积累经验，方能将这些方法了熟于心。