## 概述
Class文件是Java虚拟机执行引擎的数据入口，也是Java体系的基础构成之一。虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这就是虚拟机的加载机制。

在Java语言里面，类型的加载、链接和初始化过程都是在程序运行期间完成的，这种策略虽然会令类加载时稍微增加一些性能开销，但是会为Java程序提供高度的灵活性。试想一下一个面向接口的应用程序，可以等到运行时再指定实际的实现类，用户可以通过Java预定义和自定义类加载器，让一个本地应用的程序可以在运行时从网络或其它地方加载一个二进制流作为程序代码的一部分。这样便大大提高了应用的灵活性

## 类加载生命周期
类从被加载到虚拟机内存开始，到卸载出内存为止。总共有7个阶段。
1. 加载 Loading
2. 验证 Verification
3. 准备 Preparation
4. 解析 Resolution
5. 初始化 Initialization
6. 使用 Using
7. 卸载 Unloading

其中2，3，4这三个阶段统称为链接 Linking

## 类加载过程
#### 加载 Loading
在这个阶段主要完成3件事情
1. 通过类名来读取此类的二进制字节流
2. 将这个字节流所代表的静态存储结构转化为方法区运行时数据结构。
3. 在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。

#### 验证 Verification
简单来说此步骤就是确保Class文件的字节流中包含的信息符合当前虚拟机的要求。验证规则由于太过于细节，这里只大致罗列4条检验的方向：
1. 文件格式验证。字节流是否符合Class文件格式规范，等等。
2. 元数据验证。类是否有父类，是否继承了不允许被继承的类，等等。
3. 字节码验证。程序语义是否合法，等等。
4. 符号引用验证。发生于将符号引用转化为直接引用的时候，用于对类自身以外的信息进行匹配校验。

#### 准备 Preparation
准备阶段是正式为类变量分配内存并设置类变量初始值。这个时候内存分配仅包含类变量(static修饰的变量)，而不包括实例变量，实例变量将会在对象实例化的时候随着对象一起分配在Java堆中。

#### 解析 Resolution
虚拟机将常量池内的符号引用替换为直接引用的过程。主要包括：类或接口的解析，字段解析，类方法解析，以及接口方法解析。

#### 初始化 Initialization
这是类加载过程的最后一步。到了初始化阶段，才开始真正意义上执行类中定义的Java程序代码。

在准备阶段，变量已经赋过一次系统要求的初始值，而在初始化阶段，则根据成语元通过程序制定的主观计划去初始化类变量和其它资源。换句话说就是执行类构造器\<clinit>()的过程。

\<clinit>()这个方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块（static{}块）中的语句合并产生的，编译器收集的顺序是由语句在源文件出现的顺序决定的。静态语句块中只能访问到定义在静态语句块之前的变量，定义在后面的变量，在前面的静态语句块可以赋值，但不能访问。下面这个例子说明了这一点。
```
public class Test {
    static {
        i = 0;    // 给变量赋值可以正常编译通过
        System.out.println(i); // 访问变量则不行，会提示“非法向前引用”
    }
    static int i = 1;
}
```

\<clinit>()与构造函数\<init>()方法不同，不需要显示的调用父类构造器，虚拟机会保证在子类的\<clinit>()方法执行之前，父类的\<clinit>()方法已经执行完毕。

## 小结
这篇笔记简单总结了类加载的步骤，以及每个步骤需要完成的事情。由于这些内容太过于底层，平时也不太会用到，因此大致了解一下，有点概念就可以了，不用过多的纠结于细节。
