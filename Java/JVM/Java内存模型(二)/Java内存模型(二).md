
## 原子性、可见性和有序性
Java内存模型是围绕着在并发过程中如何处理原子性、可见性和有序性这3个特征来建立的，我们逐个来看一下哪些操作实现了这3个特性。

**原子性 (Atomicity)**: 由Java内存模型来直接保证的原子性变量操作包括 read、 load、 assign、 use、 store和 write，我们大致可以认为基本数据类型的访问读写是具备原子性的。

果应用场景需要一个更大范围的原子性保证(经常会遇到) ， Java 内存模型还提供了 lock和 unlock操作来满足这种需求，尽管虚拟机未把 lock和 unlock操作直接开放给用户使 用，但是却提供了更高层次的字节码指令 monitorenter和 monitorexit来隐式地使用这两个 操作，这两个字节码指令反映到 Java代码中就是同步块-一-synchronized关键字，因此在 synchronized 块之间的操作也具备原子性 。

**可见性 (Visibility)**: 可见性是指当一个线程修改了共享变量的值，其他线程能够立即得知这个修改。 上文在讲解volatile变量的时候我们已详细讨论过这一点。 Java内存模型是通过在变量修改后将新值同步回主内存，在变量读取前从主内存刷新变量值这种依赖主内存作为传递媒介的方式来实现可见性的，无论是普通变量还是volatile变量都是如此，普通变量与volatile变量的区别是， volatile的特殊规则保证了新值能立即同步到主内存，以及每次使用前立即从主内存刷新。因此，可以说volatile保证了多线程操作时变量的可见性，而普通 变量则不能保证这一点。

除了volatile之外， Java还有两个关键字能实现可见性，即synchronized和 final。同步块的可见性是由“对一个变量执行unlock操作之前，必须先把此变量同步回主内存中(执行store、write 操作)”这条规则获得的，而final关键字的可见性是指: 被final修饰的字段在构造器中一旦初始化完成，并且构造器没有把“this”的引用传递出去(this引用逃逸是一件很危险的事情，其他线程有可能通过这个引用访问到“初始化了一半”的对象)，那在其他线程中就能看见 final字段的值。

**有序性(Ordering)** : Java 内存模型的有序性在前面讲解volatile时也详细地讨论过了，Java程序中天然的有序性可以总结为一句话: 如果在本线程内观察，所有的操作都是有序的: 如果在一个线程中观察另 一个线程，所有的操作都是无序的。前半句是指“线程内表现为串行的语义”( Within-Thread As-If-Serial Semantics)，后半句是指“指令重排序”现象和“工作 内存与主内存同步延迟”现象。
Java语言提供了 volatile和 synchronized两个关键字来保证线程之间操作的有序性，
volatile关键字本身就包含了禁止指令重排序的语义，而 synchronized则是由“一个变量在同一个时刻只允许一条线程对其进行 lock操作”这条规则获得的，这条规则决定了持有同一个锁的两个同步块只能串行地进入。

## 先行发生原则(happens-before)
如果 Java内存模型中所有的有序性都仅仅靠volatile和synchronized来完成，那么有一些操作将会变得很烦琐，但是我们在编写Java并发代码的时候并没有感觉到这一点，这是因为Java语言中有一个“先行发生”(happens-before)的原则。这个原则非常重要，它是判断数据是否存在竞争、线程是否安全的主要依据，依靠这个原则，我们可以通过几条规则解决并发环境下两个操作之间是否可能存在冲突的所有问题。

先行发生是Java内存模型中定义的两项操作之间的偏序关系，如果说操作A先行发生于操作B，其实就是说在发生操作B之前，操作A产生的影响能被操作B观察到，“影响”包括修改了内存中共享变量的值、发送了消息、调用了方法等。这句话不难理解，但它意味着什么呢?我们可以举个例子来说明一下。
```
// 以下操作在A线程中执行
i = 1;

// 以下操作在B线程中执行
j = i;

// 以下操作在C线程中执行
i = 2;
```
假设线程A中的操作“i=1”先行发生于线程B的操作“j=i”，那么可以确定在线程 B的操作执行后，变量j的值一定等于1，得出这个结论的依据有两个: 一是根据先行发生原则 ，“i=l”的结果可以被观察到; 二是线程C还没“登场”，线程A操作结束之后没有其他线程会修改变量1的值。现在再来考虑线程C，我们依然保持线程A和线程B之间的先行发 生关系，而线程C出现在线程A和线程B的操作之间，但是线程C与线程B没有先行发生关系，那j的值会是多少呢? 答案是不确定。1和2都有可能，因为线程C对变量i的影响可能会被线程B观察到，也可能不会，这时候线程B就存在读取到过期数据的风险，不具备多线程安全性。

下面是Java内存模型下一些“天然的”先行发生关系，这些先行发生关系元须任何同步器协助就已经存在，可以在编码中直接使用。如果两个操作之间的关系不在此列，并且无法从下列规则推导出来的话，它们就没有顺序性保障，虚拟机可以对它们随意地进行重排序。

* 程序次序规则 (Program Order Rule): 在一个线程内，按照程序代码顺序，书写在前面的操作先行发生于书写在后面的操作。准确地说，应该是控制流顺序而不是程序代码顺序，因为要考虑分支、循环等结构 。
* 管程锁定规则 (Monitor Lock Rule): 一个unlock操作先行发生于后面对同一个锁的lock操作。这里必须强调的是同一个锁，而“后面”是指时间上的先后顺序。
* volatile变量规则 (Volatile Variable Rule): 对一个volatile变量的写操作先行发生于后面对这个变量的读操作，这里的“后面”同样是指时间上的先后顺序。
* 线程启动规则 (Thread Start Rule): Thread对象的 start()方法先行发生于此线程的每一个动作。
* 线程终止规则 (Thread Termination Rule): 线程中的所有操作都先行发生于对此线程的终止检测。
* 线程中断规则 (Thread Interruption Rule): 对线程 interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过 Thread.interrupted()方法检测到 是否有中断发生。
* 对象终结规则 (Finalizer Rule): 一个对象的初始化完成 (构造函数执行结束)先行发生于它的 finalize()方法的开始。
* 传递性 (Transitivity): 如果操作 A先行发生于操作 B，操作 B先行发生于操作 C, 那就可以得出操作 A 先行发生于操作 C 的结论。

Java语言无须任何同步手段保障就能成立的先行发生规则就只有上面这些了。从下面这个例子中感受一下“时间上的先后顺序”与“先行发生”之间有什么不同。
```
private int value = 0;

public void setValue(int value) {
    this.value = value;
}

public int getValue() {
    return this.value;
}
```
例子中显示的是一组再普通不过的getter/setter方法，假设存在线程 A 和 B，线程A先(时间上的先后)调用了“ setValue(1)”，然后线程 B 调用了同一个对象的“getValue()”，那么线程 B 收到的返回值是什么?

我们依次分析一下先行发生原则中的各项规则，由于两个方法分别由线程 A 和线程 B 调用，不在一个线程中，所以程序次序规则在这里不适用; 由于没有同步块，自然就不会发生lock和l unlock操作，所以管程锁定规则不适用; 由于value变量没有被volatile关键字修饰，所以volatile变量规则不适用; 后面的线程启动、终止、中断规则和对象终结规则也和这里完全没有关系。因为没有一个适用的先行发生规则，所以最后一条传递性也无从谈起，因此我们可以判定尽管线程 A 在操作时间上先于线程 B，但是无法确定线程 B 中“getValue()” 方法的返回结果，换句话说，这里面的操作不是线程安全的。

那怎么修复这个问题呢? 我们至少有两种 比较简单的方案可以选择: 要么把 getter/setter方法都定义为synchronized方法，这样就可以套用管程锁定规则; 要么把value定义为volatile变量，由于setter方法对value的修改不依赖value的原值，满足volatile关键字使用场景，这样就可以套用volatile变量规则来实现先行发生关系。

## Java与线程
最后稍微提到线程，毕竟Java里面谈论并发，大多数都与线程脱不开关系。线程是比进程更轻量级的调度执行单位，线程的引入，可以把一个进程的资源分配和执行调度分开，各个线程既可以共享进程资源(内存地址、文件 1/0 等)，又可以独 立调度(线程是 CPU 调度的基本单位)。

实现线程主要有3种方式: 使用内 核线程实现、使用用户线程实现和使用用户线程加轻量级进程混合实现。

1. 内核线程(Kernel-Level Thread, KLT)就是直接由操作系统内核( Kernel，下称内核) 支持的线程，这种线程由内核来完成线程切换，内核通过操纵调度器(Scheduler)对线程进行调度，并负责将线程的任务映射到各个处理器上 。

2. 用户线程(User Thread, UT)。用户线程指的是完全建立在用户空间的线程库上，系统内核不能感知线程存在的实现。用户线程的建立、同步、销毁和调度完全在用户态中完成，不需要内核的帮助。如果程序实现得当，这种线程不 需要 切换到内核态，因此操作可以是非常快速且低消耗的，也可以支持规模更大的线程数 量，部分高性能数据库中的多线程就是由用户线程实现的。这种进程与用户线程之间 1: N 的关系称为一对多的线程模型。

3. 用户线程和轻量级进程混合实现
在这种泪合实现下，既存在用户线程，也存在轻量级进程。用户线程还是完全建立在用户空间中，因此用户线程的创建、切换、析构等操作依然廉价，并且可以支持大规模的用户线程并发。 而操作系统提供支持的轻量级进程则作为用户线程和内 核线程之间的桥梁，这样可以使用内核提供的线程调度功能及处理器映射，并且用户线程的系统调用要通过轻量级线程来完成，大大降低了整个进程被完全阻塞的风险。在这种棍合模式中，用户线程与轻量级进程的数量比是不定的，即为 N:M 的关系。

## 小结
Java内存模型是围绕着原子性，可见性和有序性这三个特征建立的。先行发生原则则能帮我们判断是否存在并发问题的依据。理解并处理并发问题需要大量的实际经验积累，现在的学习也是相当于先敲敲门，迈出第一步。

